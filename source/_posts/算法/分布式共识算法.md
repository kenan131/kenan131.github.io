---
title: 分布式共识算法
date: 2024-06-23 21:09:19
tags: 算法
categories: 算法
---

### raft算法

Raft 是一种分布式一致性算法，用于管理分布式系统中的数据一致性。它被设计为易于理解和实现，并且提供了与Paxos算法相同的一致性保证。Raft通过选举领导者（Leader）来处理所有的客户端请求，以此来达成一致性。以下是Raft算法的一些关键概念：

1. **领导者（Leader）**：负责处理所有的客户端请求，并向其他服务器（称为追随者或候选人）复制日志条目。
2. **追随者（Follower）**：接受领导者的指令，存储日志条目，并参与领导者选举。
3. **候选人（Candidate）**：当追随者在一定时间内没有收到领导者的消息时，可能会变成候选人，并开始新的领导者选举过程。
4. **日志（Log）**：Raft中的每个节点都维护一个日志，日志中包含了所有的状态机操作。领导者负责确保所有追随者的日志都与其保持一致。
5. **任期（Term）**：Raft使用任期来跟踪领导者的生命周期。每个新领导者都会开启一个新的任期，并尝试赢得选举。
6. **选举**：当没有领导者或追随者认为领导者失效时，会触发领导者选举。候选人会请求其他节点投票，如果获得大多数节点的投票，则成为新的领导者。
7. **心跳（Heartbeat）**：领导者定期发送心跳消息给追随者，以维持其领导者地位，并确保追随者知道最新的日志信息。

#### 选举过程：

**第一阶段：所有节点都是 Follower。**

一个应用 Raft 协议的集群在刚启动（或 Leader 宕机）时，所有节点的状态都是 Follower，初始 Term（任期）为 0。同时启动选举定时器，每个节点的选举定时器超时时间都在 100~500 毫秒之间且并不一致（避免同时发起选举）。

**第二阶段：Follower 转为 Candidate 并发起投票。**

没有 Leader，Followers 无法与 Leader 保持心跳（Heart Beat），节点启动后在一个选举定时器周期内未收到心跳和投票请求，则状态转为候选者 Candidate 状态，且 Term 自增，并向集群中所有节点发送投票请求并且重置选举定时器。

注意，由于每个节点的选举定时器超时时间都在 100-500 毫秒之间，且彼此不一样，以避免所有 Follower 同时转为 Candidate 并同时发起投票请求。换言之，最先转为 Candidate 并发起投票请求的节点将具有成为 Leader 的“先发优势”。

**第三阶段：投票策略。**

节点收到投票请求后会根据以下情况决定是否接受投票请求（每个 follower 刚成为 Candidate 的时候会将票投给自己）：

请求节点的 Term 大于自己的 Term，且自己尚未投票给其它节点，则接受请求，把票投给它；

请求节点的 Term 小于自己的 Term，且自己尚未投票，则拒绝请求，将票投给自己。

**第四阶段：Candidate 转为 Leader。**

一轮选举过后，正常情况下，会有一个 Candidate 收到超过半数节点（N/2 + 1）的投票，它将胜出并升级为 Leader。然后定时发送心跳给其它的节点，其它节点会转为 Follower 并与 Leader 保持同步，到此，本轮选举结束。

注意：有可能一轮选举中，没有 Candidate 收到超过半数节点投票，那么将进行下一轮选举。

#### 其他：

> 为什么 Leader 向 Follower 发送的 Entry 是 AppendEntries 呢？

因为 Leader 与 Follower 的心跳是周期性的，而一个周期间 Leader 可能接收到多条客户端的请求，因此，随心跳向 Followers 发送的大概率是多个 Entry，即 AppendEntries。当然，在本例中，我们假设只有一条请求，自然也就是一个Entry了。

> Leader 向 Followers 发送的不仅仅是追加的 Entry（AppendEntries）。

在发送追加日志条目的时候，Leader 会把新的日志条目紧接着之前条目的索引位置（prevLogIndex）， Leader 任期号（Term）也包含在其中。如果 Follower 在它的日志中找不到包含相同索引位置和任期号的条目，那么它就会拒绝接收新的日志条目，因为出现这种情况说明 Follower 和 Leader 不一致。

> 如何解决 Leader 与 Follower 不一致的问题？

在正常情况下，Leader 和 Follower 的日志保持一致，所以追加日志的一致性检查从来不会失败。然而，Leader 和 Follower 一系列崩溃的情况会使它们的日志处于不一致状态。Follower可能会丢失一些在新的 Leader 中有的日志条目，它也可能拥有一些 Leader 没有的日志条目，或者两者都发生。丢失或者多出日志条目可能会持续多个任期。

要使 Follower 的日志与 Leader 恢复一致，Leader 必须找到最后两者达成一致的地方（说白了就是回溯，找到两者最近的一致点），然后删除从那个点之后的所有日志条目，发送自己的日志给 Follower。所有的这些操作都在进行附加日志的一致性检查时完成。

Leader 为每一个 Follower 维护一个 nextIndex，它表示下一个需要发送给 Follower 的日志条目的索引地址。当一个 Leader 刚获得权力的时候，它初始化所有的 nextIndex 值，为自己的最后一条日志的 index 加 1。如果一个 Follower 的日志和 Leader 不一致，那么在下一次附加日志时一致性检查就会失败。在被 Follower 拒绝之后，Leader 就会减小该 Follower 对应的 nextIndex 值并进行重试。最终 nextIndex 会在某个位置使得 Leader 和 Follower 的日志达成一致。当这种情况发生，附加日志就会成功，这时就会把 Follower 冲突的日志条目全部删除并且加上 Leader 的日志。一旦附加日志成功，那么 Follower 的日志就会和 Leader 保持一致，并且在接下来的任期继续保持一致。

### zab算法

ZAB算法，全称为Zookeeper Atomic Broadcast，即Zookeeper原子广播协议，是Zookeeper用来确保分布式事务最终一致性的核心算法。它是一种专为Zookeeper设计的、支持崩溃恢复的原子广播协议。以下是ZAB算法的一些关键特点：

1. **消息广播**：在ZAB协议中，所有的写请求都由Leader来处理。Leader接收请求并通过广播协议来处理，以确保所有Follower接收到相同的数据副本。
2. **角色划分**：ZAB算法中包含Leader、Follower和Observer三种角色。Leader负责处理客户端的读写请求，Follower提供读功能并参与选举，Observer提供读功能但不参与选举和过半成功策略，从而在不影响写性能的情况下提升集群的读性能。
3. **事务ID（Zxid）**：ZAB协议使用64位数字作为事务ID，其中低32位是单调递增的计数器，高32位代表Leader周期的编号（Epoch）。每个新Leader都会从其本地日志中的最大事务ZXID读取Epoch值，并加1作为新的Epoch，低32位从0开始计数。
4. **崩溃恢复**：当服务初次启动或Leader节点失败时，系统会进入恢复模式。在恢复模式中，系统会选举出一个新的Leader，然后新Leader负责将整个系统同步到最新状态。
5. **两阶段提交**：ZAB协议的消息广播过程与两阶段提交（2PC）有关，但与2PC不同，ZAB协议不需要等待所有Follower的ACK确认消息，只要半数以上的Follower成功反馈即可。

**选举的流程如下：**

- 每个Server会发出一个投票,第一次都是投自己。投票信息：（myid，ZXID）
- 收集来自各个服务器的投票
- 处理投票并重新投票，处理逻辑：优先比较ZXID,然后比较myid
- 统计投票，只要超过半数的机器接收到同样的投票信息，就可以确定leader
- 改变服务器状态，进入正常的消息广播流程。

#### ZAB消息广播过程

>  Zookeeper集群中，存在以下三种角色的节点： **Leader**：Zookeeper集群的核心角色，在集群启动或崩溃恢复中通过Follower参与选举产生，**为客户端提供读写服务，并对事务请求进行处理**。 **Follower**：Zookeeper集群的核心角色，在集群启动或崩溃恢复中参加选举，没有被选上就是这个角色，**为客户端提供读取服务**，也就是处理非事务请求，Follower不能处理事务请求，对于收到的事务请求会转发给Leader。 **Observer**：观察者角色，**不参加选举，为客户端提供读取服务，处理非事务请求**，对于收到的事务请求会转发给Leader。使用Observer的目的是为了扩展系统，提高读取性能。

1. Leader 接收到消息请求后，将消息赋予一个全局唯一的 64 位自增 id，叫做：zxid，通过 zxid 的大小比较即可实现因果有序这一特性。
2. Leader 通过先进先出队列（通过 TCP 协议来实现，以此实现了全局有序这一特性）将带有 zxid 的消息作为一个提案（proposal）分发给所有 follower。
3. 当 follower 接收到 proposal，先将 proposal 写到硬盘，写硬盘成功后再向 leader 回一个 ACK。
4. 当 leader 接收到合法数量的 ACKs 后，leader 就向所有 follower 发送 COMMIT 命令，同时会在本地执行该消息。
5. 当 follower 收到消息的 COMMIT 命令时，就会执行该消息。

**其他：**

- 新leader需要先将自身未提交的日志进行同步提交，然后才能开启自身任期内的提交。

- follow节点在重连上leader节点后，如果发现自身有未提交的日志，但是新leader没有这条日志则需要进行日志覆盖即丢失这条日志。

### raft算法和zab算法的区别

#### 相同点

- 都由 leader 来发起写操作。

- 都采用心跳检测存活性。

#### 不同点

- zab 用的是 epoch 和 count 的组合来唯一表示一个值, 而 raft 用的是 term 和 index。

- raft 协议的心跳是从 leader 到 follower, 这里注意zab协议也是一样从leader到follower。

- raft对于未提交的日志，会在新任期内的第一次提交时都进行提交。而zab算法在新任期内立即通知子节点进行提交。

